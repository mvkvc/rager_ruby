# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `io-stream` gem.
# Please instead update this file by running `bin/tapioca gem io-stream`.


# source://io-stream//lib/io/stream/shim/buffered.rb#21
class BasicSocket < ::IO
  # source://io-stream//lib/io/stream/shim/buffered.rb#38
  def buffered=(value); end

  # @return [Boolean]
  #
  # source://io-stream//lib/io/stream/shim/buffered.rb#28
  def buffered?; end

  # @return [Boolean]
  #
  # source://io-stream//lib/io/stream/shim/buffered.rb#22
  def ip_protocol_tcp?; end

  # @return [Boolean]
  #
  # source://io-stream//lib/io/stream/shim/readable.rb#19
  def readable?; end
end

# source://io-stream//lib/io/stream/shim/buffered.rb#7
class IO
  include ::Enumerable
  include ::File::Constants

  # source://io-stream//lib/io/stream/shim/buffered.rb#12
  def buffered=(value); end

  # @return [Boolean]
  #
  # source://io-stream//lib/io/stream/shim/buffered.rb#8
  def buffered?; end

  # @return [Boolean]
  #
  # source://io-stream//lib/io/stream/shim/readable.rb#8
  def readable?; end

  class << self
    # source://io-stream//lib/io/stream.rb#13
    def Stream(io); end
  end
end

class IO::Buffer
  include ::Comparable

  def initialize(*_arg0); end

  def &(_arg0); end
  def <=>(_arg0); end
  def ^(_arg0); end
  def and!(_arg0); end
  def clear(*_arg0); end
  def copy(*_arg0); end
  def each(*_arg0); end
  def each_byte(*_arg0); end
  def empty?; end
  def external?; end
  def free; end
  def get_string(*_arg0); end
  def get_value(_arg0, _arg1); end
  def get_values(_arg0, _arg1); end
  def hexdump(*_arg0); end
  def inspect; end
  def internal?; end
  def locked; end
  def locked?; end
  def mapped?; end
  def not!; end
  def null?; end
  def or!(_arg0); end
  def pread(*_arg0); end
  def private?; end
  def pwrite(*_arg0); end
  def read(*_arg0); end
  def readonly?; end
  def resize(_arg0); end
  def set_string(*_arg0); end
  def set_value(_arg0, _arg1, _arg2); end
  def set_values(_arg0, _arg1, _arg2); end
  def shared?; end
  def size; end
  def slice(*_arg0); end
  def to_s; end
  def transfer; end
  def valid?; end
  def values(*_arg0); end
  def write(*_arg0); end
  def xor!(_arg0); end
  def |(_arg0); end
  def ~; end

  private

  def initialize_copy(_arg0); end

  class << self
    def for(_arg0); end
    def map(*_arg0); end
    def size_of(_arg0); end
    def string(_arg0); end
  end
end

class IO::Buffer::AccessError < ::RuntimeError; end
class IO::Buffer::AllocationError < ::RuntimeError; end
IO::Buffer::BIG_ENDIAN = T.let(T.unsafe(nil), Integer)
IO::Buffer::DEFAULT_SIZE = T.let(T.unsafe(nil), Integer)
IO::Buffer::EXTERNAL = T.let(T.unsafe(nil), Integer)
IO::Buffer::HOST_ENDIAN = T.let(T.unsafe(nil), Integer)
IO::Buffer::INTERNAL = T.let(T.unsafe(nil), Integer)
class IO::Buffer::InvalidatedError < ::RuntimeError; end
IO::Buffer::LITTLE_ENDIAN = T.let(T.unsafe(nil), Integer)
IO::Buffer::LOCKED = T.let(T.unsafe(nil), Integer)
class IO::Buffer::LockedError < ::RuntimeError; end
IO::Buffer::MAPPED = T.let(T.unsafe(nil), Integer)
class IO::Buffer::MaskError < ::ArgumentError; end
IO::Buffer::NETWORK_ENDIAN = T.let(T.unsafe(nil), Integer)
IO::Buffer::PAGE_SIZE = T.let(T.unsafe(nil), Integer)
IO::Buffer::PRIVATE = T.let(T.unsafe(nil), Integer)
IO::Buffer::READONLY = T.let(T.unsafe(nil), Integer)
IO::Buffer::SHARED = T.let(T.unsafe(nil), Integer)

class IO::ConsoleMode
  def echo=(_arg0); end
  def raw(*_arg0); end
  def raw!(*_arg0); end

  private

  def initialize_copy(_arg0); end
end

class IO::EAGAINWaitReadable < ::Errno::EAGAIN
  include ::IO::WaitReadable
end

class IO::EAGAINWaitWritable < ::Errno::EAGAIN
  include ::IO::WaitWritable
end

class IO::EINPROGRESSWaitReadable < ::Errno::EINPROGRESS
  include ::IO::WaitReadable
end

class IO::EINPROGRESSWaitWritable < ::Errno::EINPROGRESS
  include ::IO::WaitWritable
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable
IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable
IO::PRIORITY = T.let(T.unsafe(nil), Integer)
IO::READABLE = T.let(T.unsafe(nil), Integer)

# source://io-stream//lib/io/stream/version.rb#6
module IO::Stream; end

# The default block size for IO buffers. Defaults to 64KB (typical pipe buffer size).
#
# source://io-stream//lib/io/stream/generic.rb#16
IO::Stream::BLOCK_SIZE = T.let(T.unsafe(nil), Integer)

# source://io-stream//lib/io/stream/buffered.rb#9
class IO::Stream::Buffered < ::IO::Stream::Generic
  # @return [Buffered] a new instance of Buffered
  #
  # source://io-stream//lib/io/stream/buffered.rb#40
  def initialize(io, *_arg1, **_arg2, &_arg3); end

  # source://io-stream//lib/io/stream/buffered.rb#61
  def close_read; end

  # source://io-stream//lib/io/stream/buffered.rb#65
  def close_write; end

  # @return [Boolean]
  #
  # source://io-stream//lib/io/stream/buffered.rb#57
  def closed?; end

  # Returns the value of attribute io.
  #
  # source://io-stream//lib/io/stream/buffered.rb#51
  def io; end

  # @return [Boolean]
  #
  # source://io-stream//lib/io/stream/buffered.rb#71
  def readable?; end

  # source://io-stream//lib/io/stream/buffered.rb#53
  def to_io; end

  protected

  # source://io-stream//lib/io/stream/buffered.rb#83
  def sysclose; end

  # Reads data from the underlying stream as efficiently as possible.
  #
  # source://io-stream//lib/io/stream/buffered.rb#111
  def sysread(size, buffer); end

  # source://io-stream//lib/io/stream/buffered.rb#88
  def syswrite(buffer); end

  class << self
    # source://io-stream//lib/io/stream/buffered.rb#10
    def open(path, mode = T.unsafe(nil), **options); end

    # source://io-stream//lib/io/stream/buffered.rb#22
    def wrap(io, **options); end
  end
end

# source://io-stream//lib/io/stream/generic.rb#24
class IO::Stream::Generic
  # @return [Generic] a new instance of Generic
  #
  # source://io-stream//lib/io/stream/generic.rb#25
  def initialize(block_size: T.unsafe(nil), maximum_read_size: T.unsafe(nil)); end

  # Writes `string` to the stream and returns self.
  #
  # source://io-stream//lib/io/stream/generic.rb#219
  def <<(string); end

  # Returns the value of attribute block_size.
  #
  # source://io-stream//lib/io/stream/generic.rb#40
  def block_size; end

  # Sets the attribute block_size
  #
  # @param value the value to set the attribute block_size to.
  #
  # source://io-stream//lib/io/stream/generic.rb#40
  def block_size=(_arg0); end

  # Best effort to flush any unwritten data, and then close the underling IO.
  #
  # source://io-stream//lib/io/stream/generic.rb#249
  def close; end

  # source://io-stream//lib/io/stream/generic.rb#241
  def close_read; end

  # source://io-stream//lib/io/stream/generic.rb#244
  def close_write; end

  # @return [Boolean]
  #
  # source://io-stream//lib/io/stream/generic.rb#237
  def closed?; end

  # @raise [EOFError]
  #
  # source://io-stream//lib/io/stream/generic.rb#275
  def eof!; end

  # Determins if the stream has consumed all available data. May block if the stream is not readable.
  # See {readable?} for a non-blocking alternative.
  #
  # @return [Boolean]
  #
  # source://io-stream//lib/io/stream/generic.rb#265
  def eof?; end

  # Flushes buffered data to the stream.
  #
  # source://io-stream//lib/io/stream/generic.rb#192
  def flush; end

  # source://io-stream//lib/io/stream/generic.rb#141
  def gets(separator = T.unsafe(nil), limit = T.unsafe(nil), chomp: T.unsafe(nil)); end

  # source://io-stream//lib/io/stream/generic.rb#124
  def peek(size = T.unsafe(nil)); end

  # source://io-stream//lib/io/stream/generic.rb#225
  def puts(*arguments, separator: T.unsafe(nil)); end

  # Reads `size` bytes from the stream. If size is not specified, read until end of file.
  #
  # source://io-stream//lib/io/stream/generic.rb#43
  def read(size = T.unsafe(nil)); end

  # @raise [exception]
  #
  # source://io-stream//lib/io/stream/generic.rb#74
  def read_exactly(size, exception: T.unsafe(nil)); end

  # Read at most `size` bytes from the stream. Will avoid reading from the underlying stream if possible.
  #
  # source://io-stream//lib/io/stream/generic.rb#64
  def read_partial(size = T.unsafe(nil)); end

  # Efficiently read data from the stream until encountering pattern.
  #
  # source://io-stream//lib/io/stream/generic.rb#112
  def read_until(pattern, offset = T.unsafe(nil), limit: T.unsafe(nil), chomp: T.unsafe(nil)); end

  # Whether there is a chance that a read operation will succeed or not.
  #
  # @return [Boolean]
  #
  # source://io-stream//lib/io/stream/generic.rb#284
  def readable?; end

  # This is a compatibility shim for existing code that uses `readpartial`.
  #
  # source://io-stream//lib/io/stream/generic.rb#87
  def readpartial(size = T.unsafe(nil)); end

  # Writes `string` to the buffer. When the buffer is full or #sync is true the
  # buffer is flushed to the underlying `io`.
  #
  # source://io-stream//lib/io/stream/generic.rb#204
  def write(string, flush: T.unsafe(nil)); end

  protected

  # @raise [NotImplementedError]
  #
  # source://io-stream//lib/io/stream/generic.rb#301
  def sysclose; end

  # Reads data from the underlying stream as efficiently as possible.
  #
  # @raise [NotImplementedError]
  #
  # source://io-stream//lib/io/stream/generic.rb#310
  def sysread(size, buffer); end

  # @raise [NotImplementedError]
  #
  # source://io-stream//lib/io/stream/generic.rb#305
  def syswrite(buffer); end

  private

  # Consumes at most `size` bytes from the buffer.
  #
  # source://io-stream//lib/io/stream/generic.rb#347
  def consume_read_buffer(size = T.unsafe(nil)); end

  # source://io-stream//lib/io/stream/generic.rb#182
  def drain(buffer); end

  # Fills the buffer from the underlying stream.
  #
  # source://io-stream//lib/io/stream/generic.rb#317
  def fill_read_buffer(size = T.unsafe(nil)); end

  # source://io-stream//lib/io/stream/generic.rb#91
  def index_of(pattern, offset, limit); end
end

# source://io-stream//lib/io/stream/generic.rb#21
class IO::Stream::LimitError < ::StandardError; end

# The maximum read size when appending to IO buffers. Defaults to 8MB.
#
# source://io-stream//lib/io/stream/generic.rb#19
IO::Stream::MAXIMUM_READ_SIZE = T.let(T.unsafe(nil), Integer)

# source://io-stream//lib/io/stream/string_buffer.rb#7
class IO::Stream::StringBuffer < ::String
  # @return [StringBuffer] a new instance of StringBuffer
  #
  # source://io-stream//lib/io/stream/string_buffer.rb#10
  def initialize; end

  # source://io-stream//lib/io/stream/string_buffer.rb#16
  def <<(string); end

  # source://io-stream//lib/io/stream/string_buffer.rb#16
  def concat(string); end
end

# source://io-stream//lib/io/stream/string_buffer.rb#8
IO::Stream::StringBuffer::BINARY = T.let(T.unsafe(nil), Encoding)

# source://io-stream//lib/io/stream/version.rb#7
IO::Stream::VERSION = T.let(T.unsafe(nil), String)

# Compatibility shim.
class IO::TimeoutError < ::IOError; end

IO::WRITABLE = T.let(T.unsafe(nil), Integer)

class OpenSSL::Config
  include ::Enumerable
end

class OpenSSL::Provider
  def inspect; end
  def name; end
  def unload; end

  class << self
    def load(_arg0); end
    def provider_names; end
  end
end

class OpenSSL::Provider::ProviderError < ::OpenSSL::OpenSSLError; end

class OpenSSL::SSL::SSLErrorWaitReadable < ::OpenSSL::SSL::SSLError
  include ::IO::WaitReadable
end

class OpenSSL::SSL::SSLErrorWaitWritable < ::OpenSSL::SSL::SSLError
  include ::IO::WaitWritable
end

# source://io-stream//lib/io/stream/shim/readable.rb#47
class OpenSSL::SSL::SSLSocket
  include ::Enumerable

  # source://io-stream//lib/io/stream/openssl.rb#54
  def buffered=(value); end

  # @return [Boolean]
  #
  # source://io-stream//lib/io/stream/openssl.rb#48
  def buffered?; end

  # @return [Boolean]
  #
  # source://io-stream//lib/io/stream/shim/readable.rb#49
  def readable?; end
end

module OpenSSL::Timestamp; end

class OpenSSL::Timestamp::Factory
  def additional_certs; end
  def additional_certs=(_arg0); end
  def allowed_digests; end
  def allowed_digests=(_arg0); end
  def create_timestamp(_arg0, _arg1, _arg2); end
  def default_policy_id; end
  def default_policy_id=(_arg0); end
  def gen_time; end
  def gen_time=(_arg0); end
  def serial_number; end
  def serial_number=(_arg0); end
end

class OpenSSL::Timestamp::Request
  def initialize(*_arg0); end

  def algorithm; end
  def algorithm=(_arg0); end
  def cert_requested=(_arg0); end
  def cert_requested?; end
  def message_imprint; end
  def message_imprint=(_arg0); end
  def nonce; end
  def nonce=(_arg0); end
  def policy_id; end
  def policy_id=(_arg0); end
  def to_der; end
  def to_text; end
  def version; end
  def version=(_arg0); end
end

class OpenSSL::Timestamp::Response
  def initialize(_arg0); end

  def failure_info; end
  def status; end
  def status_text; end
  def to_der; end
  def to_text; end
  def token; end
  def token_info; end
  def tsa_certificate; end
  def verify(*_arg0); end
end

class OpenSSL::Timestamp::TimestampError < ::OpenSSL::OpenSSLError; end

class OpenSSL::Timestamp::TokenInfo
  def initialize(_arg0); end

  def algorithm; end
  def gen_time; end
  def message_imprint; end
  def nonce; end
  def ordering; end
  def policy_id; end
  def serial_number; end
  def to_der; end
  def to_text; end
  def version; end
end

# source://io-stream//lib/io/stream/shim/buffered.rb#56
class StringIO
  include ::Enumerable

  # source://io-stream//lib/io/stream/shim/buffered.rb#61
  def buffered=(value); end

  # @return [Boolean]
  #
  # source://io-stream//lib/io/stream/shim/buffered.rb#57
  def buffered?; end

  # @return [Boolean]
  #
  # source://io-stream//lib/io/stream/shim/readable.rb#39
  def readable?; end
end
